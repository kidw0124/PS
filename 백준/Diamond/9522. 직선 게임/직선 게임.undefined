#include<bits/stdc++.h>
using namespace std;
using ll=long long;
using pll=pair<ll,ll>;
using ld=long double;
#ifdef kidw0124
constexpr bool ddebug=true;
#else
constexpr bool ddebug=false;
#endif

void setup(){
    if(ddebug){
        freopen("input.txt","r",stdin);
        freopen("output.txt","w",stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess(){
    ll i,j,k;

}

struct Dinic{
    using flow_t=int;
    struct Edge{
        int next;
        size_t inv;
        flow_t res;
    };
    int n;
    vector<vector<Edge>>graph;
    vector<int> q,l,start;
    void init(int _n){
        n=_n;
        graph.resize(n);
        for(int i=0;i<n;i++)graph[i].clear();
    }
    void add_edge(int s, int e, flow_t cap, flow_t caprev=0){
        Edge forward{e,graph[e].size(),cap};
        Edge reverse{s,graph[s].size(),caprev};
        graph[s].push_back(forward);
        graph[e].push_back(reverse);
    }
    bool assign_level(int source, int sink){
        int t=0;
        memset(&l[0],0,sizeof(l[0])*l.size());
        l[source]=1;
        q[t++]=source;
        for(int h=0;h<t&&!l[sink];h++){
            int cur=q[h];
            for(const auto&e:graph[cur]){
                if(l[e.next]||e.res==0)continue;
                l[e.next]=l[cur]+1;
                q[t++]=e.next;
            }
        }
        return l[sink]!=0;
    }
    flow_t block_flow(int cur, int sink, flow_t current){
        if(cur==sink)return current;
        for(int&i=start[cur];i<graph[cur].size();i++){
            auto&e=graph[cur][i];
            if(e.res==0||l[e.next]!=l[cur]+1)continue;
            if(flow_t res = block_flow(e.next,sink,min(e.res,current))){
                e.res-=res;
                graph[e.next][e.inv].res+=res;
                return res;
            }
        }
        return 0;
    }
    flow_t solve(int source, int sink){
        q.resize(n);
        l.resize(n);
        start.resize(n);
        flow_t ans=0;
        while(assign_level(source,sink)){
            memset(&start[0],0,sizeof(start[0])*n);
            while(flow_t flow=block_flow(source,sink,numeric_limits<flow_t>::max())){
                ans+=flow;
            }
        }
        return ans;
    }
};
void solve(ll tc){
    int i,j,k;
    int n;
    cin>>n;
    bitset<505>xrr,yrr;
    Dinic dinic;
    dinic.init(1003);
    int source=1001,sink=1002;
    for(i=0;i<n;i++){
        int x,y;
        cin>>x>>y;
        if(!xrr[x]){
            dinic.add_edge(source,x,1);
            xrr[x]=1;
        }
        if(!yrr[y]){
            dinic.add_edge(500+y,sink,1);
            yrr[y]=1;
        }
        dinic.add_edge(x,500+y,1);
    }

    int res=dinic.solve(source,sink);
    if(res==xrr.count()&&xrr.count()==yrr.count())cout<<"Slavko\n";
    else cout<<"Mirko\n";

}

int main(){
    setup();
    ll t=1;
//    cin>>t;
    for(int i=0;i<t;i++){
        solve(i+1);
    }
}