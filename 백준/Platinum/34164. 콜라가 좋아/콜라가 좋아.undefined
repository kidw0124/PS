#include <bits/stdc++.h>
#include <immintrin.h>
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
#ifdef kidw0124
constexpr bool ddebug = true;
#else
constexpr bool ddebug = false;
#endif
using ll = long long;
using pll = pair<ll, ll>;
using tiii = tuple<int, int, int>;
#define debug \
  if constexpr (ddebug) cout << "[DEBUG] "
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using ld= long double;
const ll mod=998244353;

ll powm(ll a, ll b, ll m = mod) {
    ll res = 1;
    a %= m;
    while (b > 0) {
        if (b & 1) res = (res * a) % m;
        a = (a * a) % m;
        b >>= 1;
    }
    return res;
}

ll modinverse(ll a, ll m) {
    ll m0 = m, t, q;
    ll x0 = 0, x1 = 1;
    if (m == 1) return 0;
    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m, a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) x1 += m0;
    return x1;
}

constexpr int MOD=998244353;
template <int32_t MOD=MOD>
struct mint {
    int32_t value;
    mint() : value() {}
    mint(int64_t value_) : value(value_ < 0 ? value_ % MOD + MOD : value_ >= MOD ? value_ % MOD : value_) {}
    mint(int32_t value_, std::nullptr_t) : value(value_) {}
    explicit operator bool() const { return value; }
    inline mint<MOD> operator + (mint<MOD> other) const { return mint<MOD>(*this) += other; }
    inline mint<MOD> operator - (mint<MOD> other) const { return mint<MOD>(*this) -= other; }
    inline mint<MOD> operator * (mint<MOD> other) const { return mint<MOD>(*this) *= other; }
    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }
    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }
    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = (uint_fast64_t)this->value * other.value % MOD; return *this; }
    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0, nullptr); }
};
template <int32_t MOD> mint<MOD> operator + (int64_t value, mint<MOD> n) { return mint<MOD>(value) + n; }
template <int32_t MOD> mint<MOD> operator - (int64_t value, mint<MOD> n) { return mint<MOD>(value) - n; }
template <int32_t MOD> mint<MOD> operator * (int64_t value, mint<MOD> n) { return mint<MOD>(value) * n; }
template <int32_t MOD> std::istream & operator >> (std::istream & in, mint<MOD> & n) { int64_t value; in >> value; n = value; return in; }
template <int32_t MOD> std::ostream & operator << (std::ostream & out, mint<MOD> n) { return out << n.value; }
vector<vector<mint<>>>ncr;
int n,m;
int cnt;
constexpr ll MAXN=2000+5;

map<tiii,mint<>>dp;

mint<> func(int rem, int maxh){
    if(dp.count({rem, maxh,cnt})) {
        return dp[{rem, maxh,cnt}];
    }
    if(rem==0){
        mint<> cc=0;
        if(cnt%3==(n+m)%3){
            int mini=max(cnt-m,n%3);
            int maxi=min(cnt-m%3,n);
            auto ncrnmc=ncr[(n+m-cnt)/3].begin()+(n-mini)/3;
            for(int i=mini;i<=maxi;i+=3,--ncrnmc){
                cc+=ncr[cnt][i]**ncrnmc;
            }
        }
        return dp[{rem, maxh,cnt}] = cc;
    }
    if(maxh==1){
        cnt+=rem;
        mint<> cc=0;
        if(cnt%3==(n+m)%3&&cnt>=n%3+m%3){
            int mini=max(cnt-m,n%3);
            int maxi=min(cnt-m%3,n);
            auto&ncrnmc=ncr[(n+m-cnt)/3];
            for(ll i=mini;i<=maxi;i+=3){
                cc+=ncr[cnt][i]*ncrnmc[(n-i)/3];
            }
        }
        cnt-=rem;
        return dp[{rem, maxh,cnt}] = cc;
    }
    mint<> cc=0;
    for(int i=1;i<=maxh;i++){
        if((i*(i+1)>>1)>rem)break;
        else {
            if(i%3==1)cnt++;
            cc+=func(rem-(i*(i+1)>>1), i);
            if(i%3==1)cnt--;
        }
    }
    return dp[{rem, maxh,cnt}] = cc;
}

void solve(ll testcase) {
    ll i, j;
    cin>>n>>m;
    cnt=0;
    dp.clear();
    clock_t start = clock();
    debug << "Testcase " << testcase << ": (n, m) = (" << n << ", " << m << ")\n";
    cout<<func(n+m,n+m) << '\n';
    clock_t end = clock();
    debug << "Time taken: " << fixed << setprecision(6) << (ld)(end - start) / CLOCKS_PER_SEC << " seconds\n";
}

void setup() {
    if (ddebug) {
        freopen("input.txt", "r", stdin);
//        freopen("output.txt", "w", stdout);
    } else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;
    ncr.resize(MAXN, vector<mint<>>(MAXN));
    for (i=0; i<MAXN; i++) {
        ncr[i][0] = ncr[i][i] = 1;
        for (j = 1; j < i; j++) {
            ncr[i][j]=ncr[i - 1][j - 1] + ncr[i - 1][j];
        }
    }
}

signed main() {
    setup();
    preprocess();
    ll t = 1;
//    cin >> t;
    for (ll testcase = 1; testcase <= t; testcase++) {
        solve(testcase);
    }
    return 0;
}
